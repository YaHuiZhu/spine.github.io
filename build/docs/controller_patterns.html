<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <title>Spine JS</title>
  </head>
  <body>
    <div role="navigation" class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" data-toggle="collapse" data-target=".navbar-collapse" class="navbar-toggle collapsed"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="https://github.com/spine/spine" title="Source on Github" class="navbar-brand">Spine</a>
          <p id="docVersion" class="navbar-text">v1.6.2</p>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/">Home</a></li>
            <li><a href="docs/">Documentation</a></li>
            <li><a href="https://github.com/spine/spine">GitHub</a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="container col-sm-3">
      <h2>Documentation</h2>
      <article>
        <div>
          <h3><a href="introduction.html">Introduction</a></h3><span>Overview of Spine</span>
        </div>
        <div>
          <h3><a href="started.html">Getting started</a></h3><span>Getting started with Spine</span>
        </div>
        <div>
          <h3><a href="controllers.html">Controllers</a></h3><span>Intro to Spine's Controllers</span>
        </div>
        <div>
          <h3><a href="models.html">Models</a></h3><span>Data storage and manipulation</span>
        </div>
        <div>
          <h3><a href="events.html">Events</a></h3><span>Custom and controller events</span>
        </div>
        <div>
          <h3><a href="routing.html">Routing</a></h3><span>HTML5 history and hash support</span>
        </div>
        <div>
          <h3><a href="views.html">Views</a></h3><span>JS Template rendering</span>
        </div>
        <div>
          <h3><a href="example.html">Examples</a></h3><span>TodoList example</span>
        </div>
        <div>
          <h3><a href="bindings.html">Two-Way Bindings</a></h3><span>Expiremental Two-Way binding module</span>
        </div>
      </article>
      <h2>Guides</h2>
      <article>
        <div>
          <h3><a href="controller_patterns.html">Controller patterns</a></h3><span>Common controller abstractions</span>
        </div>
        <div>
          <h3><a href="manager.html">Manager</a></h3><span>Controller state machine</span>
        </div>
        <div>
          <h3><a href="forms.html">Forms & Validation</a></h3><span>Process forms and validate models</span>
        </div>
        <div>
          <h3><a href="ajax.html">Ajax</a></h3><span>Custom Ajax integration with models</span>
        </div>
        <div>
          <h3><a href="hem.html">Hem</a></h3><span>Dependency management with Hem</span>
        </div>
        <div>
          <h3><a href="app.html">Spine.app</a></h3><span>Generating Spine Apps</span>
        </div>
        <div>
          <h3><a href="rails.html">Rails integration</a></h3><span>Integrate Spine with Rails using REST</span>
        </div>
        <div>
          <h3><a href="realtime.html">Realtime apps</a></h3><span>Make your Spine app realtime!</span>
        </div>
      </article>
    </div>
    <div class="container col-sm-9"><p>We’ve covered most of Spine’s Controller API in the <a href="/docs/%=%20docs_path(%22controllers%22">controller guide</a> %&gt;), so let’s have a look at some typical use cases. </p>
<p>##The Render Pattern</p>
<p>The <em>render pattern</em> is a really useful way of binding models and views together. When the controller is instantiated, it adds an event listener to the relevant model, invoking a callback when the model is refreshed or changed. The callback will invoke the <code>render()</code> function, updating the controller’s element (<code>el</code>) by replacing its contents with a rendered template. </p>
<pre><code>//= CoffeeScript
class Contacts extends Spine.Controller
  constructor: -&gt;
    super
    Contact.bind(&quot;refresh change&quot;, @render)

  template: (items) -&gt;
    require(&#39;views/contacts&#39;)(items)

  render: =&gt;
    @html(@template(Contact.all()))

//= JavaScript
var Contacts = Spine.Controller.sub({
  init: function(){
    Contact.bind(&quot;refresh change&quot;, this.proxy(this.render));
  },

  template: function(items){
    return $(&#39;#contactTemplate&#39;).tmpl(items);
  },

  render: function(){
    this.html(this.template(Contact.all()));
  }
})
</code></pre><p>This is a simple but blunt method for data binding, updating every element whenever a single record is changed. This is fine for uncomplicated and small lists, but you may find you need more control over individual elements, such as adding event handlers to items. This is where the <em>element pattern</em> comes in.</p>
<p>##The Element Pattern {#element-pattern}</p>
<p>The element pattern essentially gives you the same functionality as the render pattern, but a lot more control. It consists of two controllers, one that controls a collection of items, and the other deals with each individual item. Let’s dive right into the code to give you a good indication of how it works.</p>
<pre><code>//= CoffeeScript
class ContactItem extends Spine.Controller
  # Delegate the click event to a local handler
  events:
    &quot;click&quot;: &quot;click&quot;

  # Bind events to the record
  constructor: -&gt;
    super
    throw &quot;@item required&quot; unless @item
    @item.bind(&quot;update&quot;, @render)
    @item.bind(&quot;destroy&quot;, @remove)

  # Render an element
  render: (item) =&gt;
    @item = item if item

    @html(@template(@item))
    @

  # Use a template, in this case via Eco
  template: (items) -&gt;
    require(&#39;views/contacts&#39;)(items)

  # Called after an element is destroyed
  remove: -&gt;
    @el.remove()

  # We have fine control over events, and 
  # easy access to the record too
  click: -&gt;

class Contacts extends Spine.Controller
  constructor: -&gt;
    Contact.bind(&quot;refresh&quot;, @addAll)
    Contact.bind(&quot;create&quot;,  @addOne)

  addOne: (item) =&gt;
    contact = new ContactItem(item: item)
    @append(contact.render())

  addAll: =&gt;
    Contact.each(@addOne)

//= JavaScript
var ContactItem = Spine.Controller.sub({

  // Delegate the click event to a local handler
  events: {
    &quot;click&quot;: &quot;click&quot;
  },

  // Bind events to the record
  init: function()
    if ( !this.item ) throw &quot;@item required&quot;;
    this.item.bind(&quot;update&quot;, this.proxy(this.render));
    this.item.bind(&quot;destroy&quot;, this.proxy(remove));
  },

  render: function(item){
    if (item) this.item = item;

    this.html(this.template(this.item));
    return this;
  },

  // Use a template, in this case via jQuery.tmpl.js
  template: function(items){
    return $(&#39;#contactTemplate&#39;).tmpl(items);
  },

  // Called after an element is destroyed
  remove: function(){
    this.el.remove();
  },

  click: function(){
    // We have fine control over events, and 
    // easy access to the record too
  }
});

var Contacts = Spine.Controller.sub({
  init: function(){
    Contact.bind(&quot;refresh&quot;, this.proxy(this.addAll));
    Contact.bind(&quot;create&quot;,  this.proxy(this.addOne));
  },

  addOne: function(item){
    var contact = new ContactItem({item: item});
    this.append(contact.render());
  },

  addAll: function(){
    Contact.each(this.proxy(this.addOne));
  }
});        
</code></pre><p>In the example above, <code>Contacts</code> has responsibility for adding records when they’re initially created, and <code>ContactItem</code> has responsibility for the record’s update and destroy events, re-rendering the record when necessary. Albeit more complicated, this gives us some advantages over the previous render pattern. </p>
<p>For one thing, it’s more performant; the list doesn’t need to be re-drawn whenever a single element changes. Furthermore, we now have a lot more control over individual items. We can place event handlers, as demonstrated with the <code>click</code> callback, and manage rendering on an item by item basis.</p>
<p>##Next Steps</p>
<p>A great example of the <em>element pattern</em> is Spine’s TodoList example application, which is covered in depth in the <a href="/docs/%=%20docs_path(%22example%22">TodoList guide</a> %&gt;).</p>
</div>
  </body>
</html>